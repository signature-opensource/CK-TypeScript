using CK.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CK.EmbeddedResources;

/// <summary>
/// A CodeStoreResources is composed of 2 containers: a mutable <see cref="Code"/> container
/// in which new code generated resources can be added and an immutable <see cref="Store"/>
/// container that contains statically defined resources.
/// <para>
/// The final resources is a combination of the <see cref="Code"/> and the <see cref="Store"/>
/// in this order: Code resources may be overridden, altered, by Store ones.
/// </para>
/// <para>
/// This order is a rather arbitrary choice (it could have been the other way around) but is a required
/// convention to align the behavior of all the resource handlers. In practice, such modifications
/// of the "same" resource provider should not exist.
/// </para>
/// </summary>
/// <remarks>
/// This class is not directly serializable: the <see cref="CodeStoreResources(IResourceContainer,IResourceContainer)"/> constructor
/// must be called with deserialized containers.
/// </remarks>
[SerializationVersion( 0 )]
public sealed class CodeStoreResources
{
    readonly IResourceContainer _code;
    readonly IResourceContainer _store;

    /// <summary>
    /// Initializes a new <see cref="CodeStoreResources"/> with an explicit Code and Store container.
    /// Both of them are required but both of them may be a <see cref="EmptyResourceContainer"/>.
    /// They cannot be the same instance except if they are both EmptyResourceContainer.
    /// </summary>
    /// <param name="code">The code container. <see cref="IResourceContainer.IsValid"/> must be true.</param>
    /// <param name="store">
    /// The store container.
    /// <see cref="IResourceContainer.IsValid"/> must be true.
    /// It must not be a <see cref="CodeGenResourceContainer"/>.
    /// </param>
    public CodeStoreResources( IResourceContainer code, IResourceContainer store )
    {
        Throw.CheckArgument( code != null && code.IsValid );
        Throw.CheckArgument( store != null && store.IsValid && store is not CodeGenResourceContainer );
        Throw.CheckArgument( code != store || (code is EmptyResourceContainer && store is EmptyResourceContainer) );
        _code = code;
        _store = store;
    }

    /// <summary>
    /// Initializes a new <see cref="CodeStoreResources"/> with a Store container and an automatically
    /// created <see cref="CodeGenResourceContainer"/> for <see cref="Code"/> with a <see cref="IResourceContainer.DisplayName"/>
    /// derived from the store display name.
    /// </summary>
    /// <param name="store">The store container. It must not be a <see cref="CodeGenResourceContainer"/>.</param>
    public CodeStoreResources( IResourceContainer store )
    {
        Throw.CheckNotNullArgument( store );
        Throw.CheckArgument( store is not CodeGenResourceContainer );
        _store = store;
        var n = store is EmptyResourceContainer e ? e.NonDisabledDisplayName : store.DisplayName;
        _code = new CodeGenResourceContainer( $"[CodeGen] {n}" );
    }

    /// <summary>
    /// Gets a code generated resource container: this container is deemed to hold
    /// resources generated by code.
    /// <para>
    /// This container's content is considered mutable. It is often a writable container
    /// like a <see cref="CodeGenResourceContainer"/> or a <see cref="FileSystemResourceContainer"/>
    /// but it may also be an immutable <see cref="EmptyResourceContainer"/>: there is no constraint at this level.
    /// </para>
    /// </summary>
    public IResourceContainer Code => _code;

    /// <summary>
    /// Gets a resource container that holds stored resources. It is considered immutable. It is typically
    /// a <see cref="AssemblyResourceContainer"/> but it can be a mutable one like a <see cref="FileSystemResourceContainer"/>
    /// and in this case, its content should not be modified.
    /// <para>
    /// This can never be a <see cref="CodeGenResourceContainer"/>.
    /// </para>
    /// </summary>
    public IResourceContainer Store => _store;

    /// <summary>
    /// Gets an existing resource or a locator with <see cref="ResourceLocator.IsValid"/> false
    /// if the resource doesn't exist.
    /// <para>
    /// <see cref="Store"/> is considered first and then <see cref="Code"/> (applying the convention that Code
    /// is "before" Store).
    /// </para>
    /// </summary>
    /// <param name="resourceName">The resource name (without <see cref="ResourcePrefix"/>). Can contain any sub folder prefix.</param>
    /// <returns>The resource locator that may not be valid.</returns>
    public ResourceLocator GetResource( ReadOnlySpan<char> resourceName )
    {
        var r = _store.GetResource( resourceName );
        return r.IsValid ? r : _code.GetResource( resourceName );
    }

    /// <summary>
    /// Gets an existing folder or a ResourceFolder with <see cref="ResourceLocator.IsValid"/> false
    /// if the folder doesn't exist.
    /// <para>
    /// <see cref="Store"/> is considered first and then <see cref="Code"/> (applying the convention that Code
    /// is "before" Store).
    /// </para>
    /// </summary>
    /// <param name="folderName">The resource folder name (without <see cref="ResourcePrefix"/>). Can contain any sub folder prefix.</param>
    /// <returns>The resource folder that may not be valid.</returns>
    public ResourceFolder GetFolder( ReadOnlySpan<char> folderName )
    {
        var r = _store.GetFolder( folderName );
        return r.IsValid ? r : _code.GetFolder( folderName );
    }

    /// <summary>
    /// Overridden to return <see cref="Code"/> and <see cref="Store"/> display names.
    /// </summary>
    /// <returns>The Code and Store display names.</returns>
    public override string ToString() => $"{Code} / {Store}";

}
