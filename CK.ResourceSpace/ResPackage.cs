using CK.EmbeddedResources;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;

namespace CK.Core;

public sealed class ResPackage
{
    readonly string _fullName;
    readonly Type? _type;
    readonly NormalizedPath _defaultTargetPath;
    readonly IResourceContainer _packageResources;
    readonly CodeGenResourceContainer _codeGenResources;
    readonly string? _localPath;
    readonly ImmutableArray<ResPackage> _requires;
    readonly ImmutableArray<ResPackage> _children;
    HashSet<ResPackage>? _reachablePackages;
    readonly bool _isGroup;
    readonly int _index;

    internal ResPackage( ResPackageDescriptor d,
                         ImmutableArray<ResPackage> requires,
                         ImmutableArray<ResPackage> children,
                         int index )
    {
        _fullName = d.FullName;
        _type = d.Type;
        _defaultTargetPath = d.DefaultTargetPath;
        _packageResources = d.PackageResources;
        _codeGenResources = d.CodeGenResources;
        _localPath = d.LocalPath;
        _isGroup = d.IsGroup;
        _index = index;
        _requires = requires;
        _children = children;
    }

    /// <summary>
    /// Gets this package full name. When built from a type, this is the type's full name.
    /// </summary>
    public string FullName => _fullName;

    /// <summary>
    /// Gets the default target path that will prefix resources that are items.
    /// </summary>
    public NormalizedPath DefaultTargetPath => _defaultTargetPath;

    /// <summary>
    /// Gets a closed set of resources that have been generated by code.
    /// </summary>
    public CodeGenResourceContainer CodeGenResources => _codeGenResources;

    /// <summary>
    /// Gets the resources of the package. <see cref="IResourceContainer.IsValid"/> is necessarily true
    /// but this can be a <see cref="EmptyResourceContainer"/>.
    /// </summary>
    public IResourceContainer PackageResources => _packageResources;

    /// <summary>
    /// Gets a non null fully qualified path of this package's resources if this is a local package.
    /// </summary>
    public string? LocalPath => _localPath;

    /// <summary>
    /// Gets the type if this package is defined by a type.
    /// </summary>
    public Type? Type => _type;

    /// <summary>
    /// Gets whether this package is a group.
    /// </summary>
    public bool IsGroup => _isGroup;

    /// <summary>
    /// Gets the index in the <see cref="ResourceSpaceData.Packages"/>.
    /// </summary>
    public int Index => _index;


    /// <summary>
    /// Gets a set of packages that are reachable from this one: this is the closure
    /// of the package's requirements and children.
    /// </summary>
    public IReadOnlySet<ResPackage> ReachablePackages
    {
        get
        {
            if( _reachablePackages == null )
            {
                _reachablePackages = new HashSet<ResPackage>();
                Collect( _reachablePackages, _requires );
                Collect( _reachablePackages, _children );
            }
            return _reachablePackages;

            static void Collect( HashSet<ResPackage> set, ImmutableArray<ResPackage> deps )
            {
                foreach( var p in deps )
                {
                    if( set.Add( p ) )
                    {
                        Collect( set, p._requires );
                        Collect( set, p._children );
                    }
                }
            }
        }
    }

    /// <summary>
    /// Gets the <see cref="FullName"/> (type name if this package is defined by a type).
    /// </summary>
    /// <returns>The package full name.</returns>
    public override string ToString() => ToString( _fullName, _type );

    internal static string ToString( string fullName, Type? type )
    {
        return type != null
                ? $"{fullName} ({type.Name})"
                : fullName;
    }


}
