using CK.Setup;
using System;
using System.Diagnostics;

namespace CK.TypeScript;

/// <summary>
/// Triggers TypeScript code generation for the decorated enumeration or configures code generation for a decorated classe, struct or interface.
/// </summary>
/// <remarks>
/// Only enums can be directly handled by this attribute: other types must be generated by dedicated code generators bound
/// to the type or by global ones.
/// </remarks>
[AttributeUsage( AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Enum )]
public class TypeScriptTypeAttribute : ContextBoundDelegationAttribute, ITypeScriptTypeDecorationAttribute
{
    TypeScriptTypeDecorationImpl _impl;

    /// <summary>
    /// Initializes a new empty <see cref="TypeScriptTypeAttribute"/>.
    /// </summary>
    public TypeScriptTypeAttribute()
        : base( "CK.TypeScript.Engine.TypeScriptTypeAttributeImpl, CK.TypeScript.Engine" )
    {
    }

    /// <summary>
    /// Base class constructor for specialized <see cref="TypeScriptTypeAttribute"/> that
    /// can be bound to a specialized implementation that supports type generator
    /// (the ITSCodeGeneratorType from CK.TypeScript.Engine).
    /// </summary>
    protected TypeScriptTypeAttribute( string actualAttributeTypeAssemblyQualifiedName )
        : base( actualAttributeTypeAssemblyQualifiedName )
    {
    }

    /// <summary>
    /// Should not be used. Supports the infrastructure (and should be removed as soon as possible).
    /// </summary>
    /// <param name="other"></param>
    public TypeScriptTypeAttribute( ITypeScriptTypeDecorationAttribute other )
        : base( "CK.TypeScript.Engine.TypeScriptTypeAttributeImpl, CK.TypeScript.Engine" )
    {
        _impl = new TypeScriptTypeDecorationImpl( other );
    }

    /// <inheritdoc />
    public string? Folder 
    {
        get => _impl.Folder;
        set => _impl.Folder = value;
    }

    /// <inheritdoc />
    public string? FileName
    {
        get => _impl.FileName;
        set => _impl.FileName = value;
    }

    /// <inheritdoc />
    public string? TypeName
    {
        get => _impl.TypeName;
        set => _impl.TypeName = value;
    }

    /// <inheritdoc />
    public Type? SameFolderAs
    {
        get => _impl.SameFolderAs;
        set => _impl.SameFolderAs = value;
    }

    /// <inheritdoc />
    public Type? SameFileAs
    {
        get => _impl.SameFileAs;
        set => _impl.SameFileAs = value;
    }

    /// <summary>
    /// Combines this attribute with another one (typically the one from a <see cref="TypeScriptTypeConfiguration.ToAttribute"/>).
    /// </summary>
    /// <param name="other">The other attribute to apply.</param>
    /// <returns>This attribute.</returns>
    public TypeScriptTypeAttribute ApplyOverride( ITypeScriptTypeDecorationAttribute? other )
    {
        if( other == null ) return this;
        if( other.TypeName != null ) TypeName = other.TypeName;
        if( other.SameFileAs != null )
        {
            Debug.Assert( other.FileName == null && other.Folder == null && other.SameFolderAs == null );
            FileName = null;
            Folder = null;
            SameFolderAs = null;
            SameFileAs = other.SameFileAs;
        }
        else if( other.SameFolderAs != null )
        {
            Debug.Assert( other.Folder == null );
            Folder = null;
            SameFolderAs = other.SameFolderAs;
        }
        else
        {
            if( other.FileName != null ) FileName = other.FileName;
            if( other.Folder != null ) Folder = other.Folder;
        }
        return this;
    }
}
