using CK.Core;
using CK.Setup;
using System;
using System.Collections.Generic;
using System.Xml.Linq;

namespace CK.TypeScript;

/// <summary>
/// Triggers TypeScript code generation for the decorated enumeration or configures code generation for a decorated classe,
/// struct or interface.
/// </summary>
/// <remarks>
/// Only enums can be directly handled by this attribute: other types must be generated by dedicated code generators bound
/// to the type or by global ones.
/// </remarks>
[AttributeUsage( AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct | AttributeTargets.Enum )]
public class TypeScriptTypeAttribute : ContextBoundDelegationAttribute, ITypeScriptTypeDecorationAttribute
{
    TypeScriptTypeDecorationImpl _impl;

    /// <summary>
    /// Initializes a new empty <see cref="TypeScriptTypeAttribute"/>.
    /// </summary>
    public TypeScriptTypeAttribute()
        : base( "CK.TypeScript.Engine.TypeScriptTypeAttributeImpl, CK.TypeScript.Engine" )
    {
    }

    /// <summary>
    /// Base class constructor for specialized <see cref="TypeScriptTypeAttribute"/> that
    /// can be bound to a specialized implementation that supports type generator
    /// (the ITSCodeGeneratorType from CK.TypeScript.Engine).
    /// </summary>
    protected TypeScriptTypeAttribute( string actualAttributeTypeAssemblyQualifiedName )
        : base( actualAttributeTypeAssemblyQualifiedName )
    {
    }

    /// <summary>
    /// Should not be used. Supports the infrastructure (and should be removed as soon as possible).
    /// </summary>
    /// <param name="other"></param>
    public TypeScriptTypeAttribute( ITypeScriptTypeDecorationAttribute other )
        : base( "CK.TypeScript.Engine.TypeScriptTypeAttributeImpl, CK.TypeScript.Engine" )
    {
        _impl = new TypeScriptTypeDecorationImpl( other );
    }

    /// <inheritdoc />
    public string? Folder 
    {
        get => _impl.Folder;
        set => _impl.Folder = value;
    }

    /// <inheritdoc />
    public string? FileName
    {
        get => _impl.FileName;
        set => _impl.FileName = value;
    }

    /// <inheritdoc />
    public string? TypeName
    {
        get => _impl.TypeName;
        set => _impl.TypeName = value;
    }

    /// <inheritdoc />
    public Type? SameFolderAs
    {
        get => _impl.SameFolderAs;
        set => _impl.SameFolderAs = value;
    }

    /// <inheritdoc />
    public Type? SameFileAs
    {
        get => _impl.SameFileAs;
        set => _impl.SameFileAs = value;
    }

    /// <summary>
    /// Updates this attribute with another one. <paramref name="other"/>'s configurations win.
    /// </summary>
    /// <param name="other">The other attribute to apply.</param>
    /// <returns>This attribute.</returns>
    public TypeScriptTypeAttribute ApplyOverride( ITypeScriptTypeDecorationAttribute? other )
    {
        if( other == null ) return this;
        if( other.TypeName != null ) TypeName = other.TypeName;
        if( other.SameFileAs != null )
        {
            Throw.DebugAssert( other.FileName == null && other.Folder == null && other.SameFolderAs == null );
            FileName = null;
            Folder = null;
            SameFolderAs = null;
            SameFileAs = other.SameFileAs;
        }
        else if( other.SameFolderAs != null )
        {
            Throw.DebugAssert( other.Folder == null );
            Folder = null;
            SameFolderAs = other.SameFolderAs;
        }
        else
        {
            if( other.FileName != null ) FileName = other.FileName;
            if( other.Folder != null ) Folder = other.Folder;
        }
        return this;
    }

    /// <summary>
    /// Initializes a <see cref="TypeScriptTypeAttribute"/> from the attributes of a xml element.
    /// Returns null when the element doesn't contain any TypeScript related attributes.
    /// </summary>
    /// <param name="e">The xml element.</param>
    public static TypeScriptTypeAttribute? ReadFrom( XElement e )
    {
        TypeScriptTypeAttribute? result = null;
        string? typeName = (string?)e.Attribute( TypeScriptAspectConfiguration.xTypeName );
        if( !string.IsNullOrWhiteSpace( typeName ) )
        {
            result = new TypeScriptTypeAttribute();
            result.TypeName = typeName;
        }

        string? sameFileAs = (string?)e.Attribute( TypeScriptAspectConfiguration.xSameFileAs );
        if( !string.IsNullOrWhiteSpace( sameFileAs ) )
        {
            result ??= new TypeScriptTypeAttribute();
            result.SameFileAs = SimpleTypeFinder.WeakResolver( sameFileAs, throwOnError: true )!;
        }

        string? sameFolderAs = (string?)e.Attribute( TypeScriptAspectConfiguration.xSameFolderAs );
        if( !string.IsNullOrWhiteSpace( sameFolderAs ) )
        {
            result ??= new TypeScriptTypeAttribute();
            result.SameFolderAs = SimpleTypeFinder.WeakResolver( sameFolderAs, throwOnError: true )!;
        }

        string? folder = (string?)e.Attribute( TypeScriptAspectConfiguration.xFolder );
        if( folder != null )
        {
            result ??= new TypeScriptTypeAttribute();
            result.Folder = folder;
        }

        string? fileName = (string?)e.Attribute( TypeScriptAspectConfiguration.xFileName );
        if( !string.IsNullOrWhiteSpace( fileName ) )
        {
            result ??= new TypeScriptTypeAttribute();
            result.FileName = fileName;
        }
        return result;
    }

    internal IEnumerable<XAttribute> ToXmlAttributes()
    {
        if( TypeName != null ) yield return new XAttribute( TypeScriptAspectConfiguration.xTypeName, TypeName );
        if( Folder != null ) yield return new XAttribute( TypeScriptAspectConfiguration.xFolder, Folder );
        if( FileName != null ) yield return new XAttribute( TypeScriptAspectConfiguration.xFileName, FileName );
        if( SameFolderAs != null ) yield return new XAttribute( TypeScriptAspectConfiguration.xSameFolderAs, SameFolderAs );
        if( SameFileAs != null ) yield return new XAttribute( TypeScriptAspectConfiguration.xSameFileAs, SameFileAs );
    }
}


